To develop my application I used \textit{Vue Native} [ \url{https://vue-native.io/} ]; it is a Javascript framework to build cross-platform application that inherits the main features from \textit{Vue.js} and \textit{React Native}.\\ 

I also used several external services and libraries.
Some external libraries are necessary for the correct behavior of the application and to have not to waste time in implementing code in order to achieve the objective that these external services already provide.\\

Now, I will present the main external services and libraries that I have used and integreted in \textit{MOQA}.

\section{Vuex}
Vuex is a state management pattern library for \textit{Vue.js} [ \url{https://vuex.vuejs.org/} ] applications. It serves as a centralized store for all the components in an application, with rules ensuring that the state can only be mutated in a predictable fashion. It is based on the state store manager library \textit{Redux} of \textit{React Native}.\\

I have made a custom change to manage the persistence on the phone, using \textit{AsyncStorage} from \textit{React Native} instead of the \textit{localStorage} used in the web.

\input{./files/code/storageHandler.tex}

\section{Maps, Charts and DateTimePicker}
\textit{Vue Native} has not its own component to build a map or a chart. So, as expleined in the official documentation, I used the community components of \textit{React Native}.\\

It was easy to import the components and the integration does not require any type of effort. Making an example, in the \textit{<script>} section of the code I had to insert:

\medskip
\begin{lstlisting}[style=htmlcssjs]
// Import of MapView from react-native
// react-native-maps is the library maintained
// by the react-native community
import MapView, {Circle} from "react-native-maps";

// Export of the component in Vue Native
export default {
    components: {
      MapView, Circle, Icon
    },
    
}
\end{lstlisting}

Using the above code, in the \textit{<template>} section, we can use \textit{<map-view>} as component of \textit{Vue Native}.

\section{Arduino Data}
According to the other two people involved in the project, we decided to develop an online RestfulAPI to manage the storage and the retrieve of the data generated by the Arduino board.\\

This RestfulAPI was designed using Swagger [ \url{https://swagger.io/} ], developed using \textit{Node.js} [ \url{https://nodejs.org/} ] framework and delivered with the web-platform \textit{Heroku} [ \url{https://www.heroku.com/} ].\\

The web server is available at \url{https://polimi-dima-server.herokuapp.com/}.\\

All the backend is developed using Javascript code and the default \textit{npm} as package manager.\\

The starting point with function declarations and interfaces was generated through the \textit{Swagger} file using the \textit{Swagger Editor} [ \url{https://editor.swagger.io/} ] service.\\

Relevant package added are:
\begin{itemize}
    \item \textit{node-postgres} (aka pg) is a collection of Node.js modules for interfacing with your PostgreSQL database;
    \item \textit{knex.js} is a SQL query builder for Postgres designed to be flexible, portable, and easy to use;
    \item \textit{serve-static} creates a new middleware function to serve files from within a given root directory. The file to serve will be determined by combining req.url with the provided root directory;
    \item \textit{JSON Web Tokens} (aka jwt) is standard method for representing claims securely between two parties. The package allows you to decode, verify and generate JWT .
\end{itemize}

\section{ARPA Data}
ARPA data are not available from the official web-site of the institute, but they are provided by the OpenData service offered by \textit{Regione Lombardia} [ \url{https://www.dati.lombardia.it/} ].\\

\textit{Regione Lombardia} offers a web tool to visualize, aggragate and export data; unlimited downloads of datasets in different formats (e.g. csv, json, ecc...).
Moreover, it offers a web API to access a specific dataset.\\

Data about the monitoring stations are returned as a \textit{GeoJSON} file. The file contains an array of sensors, each one associated to a station, its position, its typology, unit of measure and altitude.\\

Sampled data are returned as objects in an array. For each datum is present the id number of the sensor, the value and the timestamp.
